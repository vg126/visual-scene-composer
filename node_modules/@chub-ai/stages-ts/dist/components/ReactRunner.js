var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/***
 The runner code for a stage inside an iFrame.
 If you're writing a stage, reading this won't be useful.
 If you aren't, why are you here?
 @link https://lfs.charhub.io/important_message
 ***/
import React, { useEffect, useState } from "react";
import { DEFAULT_INITIAL, DEFAULT_LOAD_RESPONSE, DEFAULT_RESPONSE } from "../types/defaults";
import { Loading } from "./Loading";
import { ALLOWED_ORIGINS } from "../services/messaging";
const INIT = 'INIT';
const BEFORE = 'BEFORE';
const AFTER = 'AFTER';
const SET = 'SET';
const CALL = 'CALL';
const MESSAGE_TYPES = new Set([INIT, BEFORE, AFTER, SET]);
export const ReactRunner = ({ factory, debug = false }) => {
    const [stage, setStage] = useState(null);
    const [node, setNode] = useState(new Date());
    const [previous, setPrevious] = useState({ key: '', value: {} });
    function sendMessage(messageType, message) {
        window.parent.postMessage({ "messageType": messageType, "data": message }, '*');
    }
    useEffect(() => {
        const handleMessage = (event) => __awaiter(void 0, void 0, void 0, function* () {
            try {
                if (!ALLOWED_ORIGINS.has(event.origin)) {
                    console.warn('Received message from unauthorized origin: ', event.origin);
                    return;
                }
                if (event.source !== window.parent) {
                    console.warn('Received message from unauthorized source: ', event.source);
                    return;
                }
                const { messageType, data } = event.data;
                if (debug && MESSAGE_TYPES.has(messageType)) {
                    console.debug('Stages iFrame received event from origin: ', event.origin);
                    console.debug('Stages iFrame received data: ', event.data);
                }
                const answerKey = messageType + ': ' + JSON.stringify(data);
                if (previous.key == answerKey) {
                    if (debug) {
                        console.debug('Already seen, returning previous');
                    }
                    sendMessage(messageType, previous.value);
                }
                else if (messageType == 'INIT') {
                    if (stage != null) {
                        console.warn("INIT message for non-null stage.");
                        sendMessage('INIT', Object.assign({}, DEFAULT_LOAD_RESPONSE));
                        setPrevious(Object.assign(Object.assign({}, previous), { key: answerKey }));
                    }
                    else {
                        let newStage = factory(Object.assign(Object.assign({}, DEFAULT_INITIAL), data));
                        const canContinue = yield newStage.load();
                        const response = Object.assign(Object.assign({}, DEFAULT_LOAD_RESPONSE), canContinue);
                        setPrevious({ key: answerKey, value: response });
                        sendMessage('INIT', response);
                        setStage(newStage);
                    }
                }
                else if (stage == null) {
                    console.warn('Null stage instance for non-INIT message.');
                }
                else if (messageType == 'BEFORE') {
                    const beforeResponse = yield (stage === null || stage === void 0 ? void 0 : stage.beforePrompt(Object.assign({}, data)));
                    const response = Object.assign(Object.assign({}, DEFAULT_RESPONSE), beforeResponse);
                    setPrevious({ key: answerKey, value: response });
                    sendMessage('BEFORE', response);
                }
                else if (messageType == 'AFTER') {
                    const afterResponse = yield (stage === null || stage === void 0 ? void 0 : stage.afterResponse(Object.assign({}, data)));
                    const response = Object.assign(Object.assign({}, DEFAULT_RESPONSE), afterResponse);
                    setPrevious({ key: answerKey, value: response });
                    sendMessage('AFTER', response);
                }
                else if (messageType == 'SET') {
                    yield (stage === null || stage === void 0 ? void 0 : stage.setState(data));
                    setPrevious({ key: answerKey, value: {} });
                    sendMessage('SET', {});
                }
                else if (messageType == CALL) {
                    const { functionName, parameters } = data;
                    if (stage.hasOwnProperty(functionName)) {
                        const result = stage[functionName](parameters);
                        sendMessage(CALL, {
                            functionName,
                            result
                        });
                    }
                    else {
                        console.error(`Function '${functionName}' does not exist on the stage.`);
                        sendMessage(CALL, {
                            functionName,
                            result: null
                        });
                    }
                }
            }
            catch (exception) {
                console.error('Stages iFrame had an unexpected error: ', exception);
                window.parent.postMessage({
                    "messageType": 'ERROR', "data": {
                        name: exception.name,
                        message: exception.message,
                        stack: exception.stack
                    }
                });
            }
            finally {
                setNode(new Date());
            }
        });
        window.removeEventListener('message', handleMessage);
        window.addEventListener('message', handleMessage);
        return () => {
            window.removeEventListener('message', handleMessage);
        };
    }, [stage]);
    return React.createElement(React.Fragment, null,
        React.createElement("div", { style: { display: 'none' } },
            String(node),
            window.location.href),
        stage == null ? React.createElement(Loading, null) : stage.render());
};
